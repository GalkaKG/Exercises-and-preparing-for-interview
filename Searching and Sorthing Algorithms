QuickSort
----------
- efficient sorting algorithm
- Choose a pivot; move smaller elements left & larger right; sort left & right
- Memory: O(log(n)) stack space (recursion)
- Time: O(n2) when the pivot element divides the array into two unbalanced sub-arrays (huge difference in size)
- Stable: Depends
- Method: Partitioning

Code exaple:
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# Example usage
unsorted_list = [3, 6, 8, 10, 1, 2, 1]
sorted_list = quick_sort(unsorted_list)
print(sorted_list)


Merge Sort
-----------
- Merge sort is efficient sorting algorithm 
- Divide the list into sub-lists (typically 2 sub-lists)
    1. Sort each sub-list (recursively call merge-sort)
    2. Merge the sorted sub-lists into a single list
- Memory: O(n) / O(n*log(n))
- Time: O(n*log(n))
- Highly parallelizable on multiple cores / machines -> up to O(log(n))

Code exaple:
